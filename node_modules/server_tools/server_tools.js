//These functions are meant to help the server-side master (app.js)
var server_tools=new Object();
//This function takes a database object and a database query, and returns a JSON object which answers the query
//WARNING: the query object must contain two members: query.db specifies the name of the database, query.message contains the query itself
server_tools.queryDatabase=function(database, query, socket)
{
	console.log(query.tag);
	if(query.msg=='')
	{
		if(query.tag=='station_list')
		{
			database.collection('stationlist').find().toArray(function(err,items)
			{
				if(err!=null) console.log(err);
				for(var i=0; i<items.length; i++)
				{
					items[i].birth_date=unixTimestampToJavascriptDate(items[i].birth_date);
				}
				var response={data:items, query:query};
				socket.emit('database_response_station_list', response);
				
			});
		}
		else if(query.tag=='error_prone_list')
		{
			database.collection('errorlist').find().sort({ground_station_id:1}).toArray(function(err,items)
			{
				database.collection('stationlist').find().sort({id:1}).toArray(function(err, stations)
				{
					if(err!=null) console.log(err);
					var temp=buildErrorProneList(items, stations);
					var response={data:temp, query:query};
					
					socket.emit('database_response_error_prone_list', response);
				});

			});
		}
		else if(query.tag=='recent_error_list')
		{
			database.collection('errorlist').find().sort({timestamp:-1}).toArray(function(err, items)
			{
				if(err!=null) console.log(err);

				for(var i=0; i<items.length; i++)
				{
					items[i].timestamp=unixTimestampToJavascriptDate(items[i].timestamp);
				}

				var response={data:items, query:query};
				socket.emit('database_response_recent_error_list', response);
			});
		}
		else if(query.tag=='module_failure_plot')
		{
			database.collection('errorlist').find().sort({module:1}).toArray(function(err, items)
			{
				console.log('module_error_plot');
				var temp=buildModuleFailureList(items, query.startDate, query.endDate);
				var response={data:temp, query:query};

				socket.emit('database_response_module_failure_plot', response);
			});

		}
		else if(query.tag=='swaps_before_failure_date')
		{
			database.collection('errorlist').find().sort({ground_station_id:1, timestamp:1}).toArray(function(err, items)
			{
				var temp=buildSwapsBeforeFailureDate(items);

				var response={data:temp, query:query};

				socket.emit('database_response_swaps_before_failure_data', response);
			});
		}
	}
	else if(query.tag=='swaps_before_failure_gs_average')
	{
		database.collection('errorlist').find().sort({ground_station_id:1}).toArray(function(err, items){
			var temp=buildSwapsBeforeFailureGSAverage(items);

			var response={data:temp, query:query};

			socket.emit('database_response_swaps_before_failure_gs_average', response);
		});
	}
	else if(query.tag=='swaps_before_failure_gs_best')
	{
		database.collection('errorlist').find().sort({ground_station_id:1}).toArray(function(err, items){
			var temp=buildSwapsBeforeFailureGSBest(items);

			var response={data:temp, query:query};

			socket.emit('database_response_swaps_before_failure_gs_best', response);
		});
	}
	else if(query.tag=='swaps_before_failure_gs_recent')
	{
		database.collection('errorlist').find().sort({ground_station_id:1, timestamp:-1}).toArray(function(err, items){
			var temp=buildSwapsBeforeFailureGSRecent(items);

			var response={data:temp, query:query};

			socket.emit('database_response_swaps_before_failure_gs_recent', response);
		});
	}
	else
	{
		database.collection(query.collection).find(query.msg).toArray(function(err,items)
		{
			if(err!=null) console.log(err);
			returnJSON=items;
		});
	}
	return;
}

function buildSwapsBeforeFailureDate(data)
{
	//the argument of this function should be an array of errors sorted by ground station and then by timestamp
	var returnArray=[]; //this is an array of objects which are each an array of date/swaps_before_fail pairs
	var stationArray=[];
	for(var i=0; i<data.length; i++)
	{
		data[i].timestamp+=i;
		data[i].timestamp=unixTimestampToJavascriptDate(data[i].timestamp);
		if(i==0)
		{
			stationArray.push(data[i]);
		}
		else if(data[i].ground_station_id!=data[i-1].ground_station_id)
		{
			//we are now talking about a new groundstation
			returnArray.push(stationArray);
			returnArray[returnArray.length-1].ground_station_id=data[i-1].ground_station_id;
			stationArray=[];
		}
		else
		{
			//add more entries to the same ground station
			stationArray.push(data[i]);
		}

	}
	console.log("BIG TIME");
	console.log(returnArray)

	return returnArray;
}

function buildSwapsBeforeFailureGSAverage(items)
{
	//creates a list of objects (prototypeObject) for use in the swap-before-failure-gs-average plot
	var returnArray=[]; 
	var prototypeObject={ground_station_id:0, total_swaps:0, total_samples:0, average_swaps_before_error:0};
	var push;
	for(var i=0; i<data.length; i++)
	{
		push=false;
		if(i==0)
		{
			prototypeObject.ground_station_id=data[i].ground_station_id;
			prototypeObject.total_swaps+=data[i].swaps_before_error;
			prototypeObject.total_samples+=1;
			if(data.length==1) push=true;
		}
		else if(data[i].ground_station_id!=data[i-1].ground_station_id)
		{
			//we are now talking about a new groundstation
			push=true;
		}
		else
		{
			//add more data to the same ground station
			prototypeObject.total_swaps+=data[i].swaps_before_error;
			prototypeObject.total_samples+=1;
			if(data.length-1==i) push=true;

		}
		if(push)
		{
			prototypeObject.average_swaps_before_error=prototypeObject.total_swaps/prototypeObject.total_samples;
			returnArray.push(prototypeObject);
			prototypeObject={ground_station_id:data[i].ground_station_id, total_swaps:data[i].swaps_before_error, total_samples:1, average_swaps_before_error:0};
		}

	}
	return returnArray;
}

function buildSwapsBeforeFailureGSBest(items)
{
	//creates a list of objects (prototypeObject) for use in the swap-before-failure-gs-average plot
	var returnArray=[]; 
	var prototypeObject={ground_station_id:0, best_swaps_before_error:0};
	var push;
	for(var i=0; i<data.length; i++)
	{
		push=false;
		if(i==0)
		{
			prototypeObject.ground_station_id=data[i].ground_station_id;
			prototypeObject.best_swaps_before_error=data[i].swaps_before_error;
			if(data.length==1) push=true;
		}
		else if(data[i].ground_station_id!=data[i-1].ground_station_id)
		{
			//we are now talking about a new groundstation
			push=true;
		}
		else
		{
			//add more data to the same ground station
			if(prototypeObject.best_swaps_before_error<=data[i].swaps_before_error) prototypeObject.best_swaps_before_error=data[i].swaps_before_error;
			if(data.length-1==i) push=true;
		}
		if(push)
		{
			returnArray.push(prototypeObject);
			prototypeObject={ground_station_id:data[i].ground_station_id, best_swaps_before_error:data[i].swaps_before_error};
		}

	}
	return returnArray;
}

function buildSwapsBeforeFailureGSRecent(items)
{
	//creates a list of objects (prototypeObject) for use in the swap-before-failure-gs-average plot
	var returnArray=[]; 
	var prototypeObject={ground_station_id:0, recent_swaps_before_error:0};
	var push;
	for(var i=0; i<data.length; i++)
	{
		push=false;
		if(i==0)
		{
			prototypeObject.ground_station_id=data[i].ground_station_id;
			prototypeObject.recent_swaps_before_error=data[i].swaps_before_error;
			push=true;
		}
		else if(data[i].ground_station_id!=data[i-1].ground_station_id)
		{
			//we are now talking about a new groundstation
			push=true;
		}
		if(push)
		{
			returnArray.push(prototypeObject);
			prototypeObject={ground_station_id:data[i].ground_station_id, best_swaps_before_error:data[i].swaps_before_error};
		}

	}
	return returnArray;
}



function buildErrorProneList(data, stationdata)
{
	//the input should be a set of documents from the errorlist database, which will be sorted by ground station id.
	//This function returns a JSON object which can be passed directly to jqGrid

	var returnArray=[];
	//Needs 4 properties: ground_station_id, lifetime_errors, last_error, and most_recent_error
	
	for(var i=0; i<data.length; i++)
	{
		if(i==0)
		{
			returnArray.push({ground_station_id:data[i].ground_station_id, lifetime_errors:getStationById(data[i].ground_station_id, stationdata).lifetime_errors, last_error: data[i].timestamp, most_recent_error: data[i].timestamp});
		}
		else if(data[i].ground_station_id!=data[i-1].ground_station_id)
		{
			//we are now talking about a new groundstation
			returnArray.push({ground_station_id:data[i].ground_station_id, lifetime_errors:getStationById(data[i].ground_station_id, stationdata).lifetime_errors, last_error: data[i].timestamp, most_recent_error: data[i].timestamp});
		}
		else
		{
			returnArray[returnArray.length-1].lifetime_errors++;
			if(returnArray[returnArray.length-1].last_error<data[i].timestamp) returnArray[returnArray.length-1].last_error=data[i].timestamp;
			if(returnArray[returnArray.length-1].most_recent_error>data[i].timestamp) returnArray[returnArray.length-1].most_recent_error=data[i].timestamp;
		}
	}

	for(var i=0; i<returnArray.length; i++)
	{
		returnArray[i].last_error=unixTimestampToJavascriptDate(returnArray[i].last_error);
		returnArray[i].most_recent_error=unixTimestampToJavascriptDate(returnArray[i].most_recent_error);
	}

	return returnArray;
}

function buildModuleFailureList(data, startDate, endDate)
{
	//This will order the module failures by module.
	var returnArray=[];

	//This will exclude errors that do not fall in the range of dates specified by startDate and endDate
	var dataBuffer=[];


	startDate=convertDashDateToUnixTimestamp(startDate);
	endDate=convertDashDateToUnixTimestamp(endDate);
	for(var i=0; i<data.length; i++)
	{
		if(data[i].timestamp>startDate && data[i].timestamp<endDate)
		{ 
			dataBuffer.push(data[i]);
		}
	}
	for(var i=0; i<dataBuffer.length; i++)
	{
		if(i==0)
		{
			returnArray.push({module:dataBuffer[i].module, errors:1});
		}
		else if(dataBuffer[i].module==dataBuffer[i-1].module)
		{
			returnArray[returnArray.length-1].errors++;
		}
		else
		{
			returnArray.push({module:dataBuffer[i].module, errors:1});
		}
	}
	return returnArray;
}

function unixTimestampToJavascriptDate(timestamp)
{
	var tempDate=new Date(timestamp*1000);
    return (tempDate.toLocaleTimeString() + "  " + (tempDate.getMonth()+1) + "/" + tempDate.getDate() + "/" + tempDate.getFullYear());
}

function getStationById(id, stationlist)
{
	for(var i=0; i<stationlist.length; i++)
	{
		if(stationlist[i].id==id) return stationlist[i];
	}
	return null;
}

function convertDashDateToUnixTimestamp(dashdate)
{
	//the argument is a date string that looks like mm-dd-yyyy, e.x. 01-01-1970

	var parts=dashdate.split("-");
	if(parts.length!=3) throw "Invalid Date Format";

	var myDate=new Date(dashdate);
	return myDate.getTime()/1000.0;

}


module.exports=server_tools;